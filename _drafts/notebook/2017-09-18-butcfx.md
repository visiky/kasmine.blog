---
layout: post
title: 2017-09-18-butcfx
tags:
---

## æ ¸å¿ƒæ¦‚å¿µ
* çªå˜å’Œä¸å¯å˜
* å®‰å…¨çš„ä»¥ä¸å˜çš„æ–¹å¼æ›´æ–°å¯¹è±¡å’Œæ•°ç»„
* é¿å…åœ¨å‡½æ•°å’Œè¯­å¥ä¸­çªå˜state


> **å…³äºä¸å¯å˜å’Œçªå˜**
> ä¸ºäº†æå‡æ€§èƒ½ï¼Œ`connect`ä½¿ç”¨äº†ä¸€äº›ä¾èµ–äºä¸å¯å˜ state çš„æ–¹æ³•ã€‚å¹¶ä¸”ä½¿ç”¨æµ…å¼•ç”¨ï¼ˆshallow referenceï¼‰æ¥æ£€æµ‹çŠ¶æ€çš„æ”¹å˜ã€‚è¿™æ„å‘³ç€**ç›´æ¥ä¿®æ”¹å¯¹è±¡æˆ–è€…æ•°ç»„æ˜¯ä¸ä¼šè¢«æ£€æµ‹åˆ°çš„å¹¶ä¸”ç»„ä»¶ä¸ä¼šè¢«é‡æ–°æ¸²æŸ“ã€‚**


## é˜…è¯»åˆ—è¡¨
* [ ] [åœ¨ React ä¸­ä½¿ç”¨ Immutable ç‰¹æ€§çš„ä¼˜ç¼ºç‚¹](http://reactkungfu.com/2015/08/pros-and-cons-of-using-immutability-with-react-js/)
* [ ] [Javascript å’Œ Immutable ç‰¹æ€§](http://t4d.io/javascript-and-immutability/)
* [x] [ä½¿ç”¨ ES6 çš„ Immutable æ•°æ®åŠå…¶å»¶ä¼¸](http://wecodetheweb.com/2016/02/12/immutable-javascript-using-es6-and-beyond/)
* [x] [Immutable æ•°æ®ä»é›¶å¼€å§‹](https://ryanfunduk.com/articles/immutable-data-from-scratch/)
* [x] [Redux æ–‡æ¡£: ä½¿ç”¨å¯¹è±¡å±•å¼€ç¬¦](http://cn.redux.js.org/docs/recipes/UsingObjectSpreadOperator.html)



### JavaScript and Immutability
* ä½¿ç”¨constå£°æ˜å˜é‡
* æ··åˆä½¿ç”¨Object.assign
  * `Object.assign({}, object, newObject);`
* å¯¹æ•°ç»„çš„æ“ä½œ
  * ä½¿ç”¨concatä»£æ›¿pushå’Œunshift
  * ä½¿ç”¨sliceä»£æ›¿shiftå’Œpop

```markup
var colors = ['red','green','blue'];  
var newColors = [].concat('orange').concat(colors);  
// newColors contains ['orange','red','green','blue']
// colors !== newColors
```

* [ä½¿ç”¨freezing](https://lark.alipay.com/xinming.lxj/notebook/gn5k2l)


ğŸš” The **freeze **function prevents the modification of existing property attributes and values, and prevents the addition of new properties, note that is a <span style="background-color:#FFF9D8;">**shallow freeze**</span>. 

### Immutableæ•°æ®ä»é›¶å¼€å§‹(Immutable Data from Scratch)
* [ ] [React from Scratch](https://ryanfunduk.com/articles/react-from-scratch)


**Make objects immutable**
```javascript
function immutable( obj ) {
  // already immutable!
  if( obj && obj.hasOwnProperty('__immutable') ) {
    return obj
  }

  let newObj

  if( Array.isArray( obj ) ) {
    newObj = []

    // first make all elements immutable
    for( let i in obj ) {
      newObj[i] = immutable( obj[i] )
    }

    // then DISABLE all mutating methods of the array itself
    let unsafe = [ 'push', 'pop', 'sort', 'splice',
                   'shift', 'unshift', 'reverse' ]
    let fail = function() {
      throw new Error('Cannot modify immutable object')
    }
    unsafe.forEach( function( fn ) {
      Object.defineProperty( newObj, fn, { value: fail } )
    } )
  }
  else if( obj && typeof( obj ) == 'object' ) {
    // make all values in the object immutable
    newObj = {}
    for( let i in obj ) {
      newObj[i] = immutable( obj[i] )
    }
  }
  else {
    // primitive
    return obj
  }

  // add 'already immutable' property
  Object.defineProperty( newObj, '__immutable', { /*defaults*/ } )
  // prevent any more edits of any kind ğŸ±
  return Object.freeze( newObj )
}
```

**Wrap function-render-watchcomponent in a sort of memoizing function:**

```javascript
function pure( componentFn, immutableProp ) {
  // keep track of props and render results
  const memoizedRenders = {};

  return function( props ) {
    // the prop we are considering ourselves pure 'against'
    const prop = props[immutableProp];

    // attempt to find a memoized render
    // for this prop and id
    const memoized = memoizedRenders[prop.id];

    // if we found one and the memoized value is
    // the exact same object as the new prop
    // then we don't need to render because the
    // result would be the same!
    if( memoized && memoized.value === prop ) {
      return memoized.result;
    }
    // otherwise, render and store the results
    // for later lookup
    else {
      const result = componentFn( props );
      memoizedRenders[prop.id] = { value: prop, result: result };
      return result;
    }
  };
}
```
* ç”¨æ³•:

```markup
TodoApp = pure( TodoApp, 'todos' )
TodoItem = pure( TodoItem, 'todo' )
```
* åœºæ™¯

æ¯”å¦‚åœ¨Liståˆ—è¡¨ä¸­ï¼Œæ¯ä¸€ä¸ªlistItemæ˜¯ç‹¬ç«‹çš„ç»„ä»¶ï¼Œæ›´æ–°listä¸­çš„æŸä¸€ä¸ªitemï¼Œä½¿ç”¨pureRenderå¯ä»¥é¿å…ç»„ä»¶é‡æ–°æ¸²æŸ“(ç±»ä¼¼React.PureComponent)

[Demo](https://codepen.io/rfunduk/pen/MwpzNE?editors=0010) (ä»…ä½œä¸ºå‚è€ƒæ€è·¯)

### **ä½¿ç”¨å¯¹è±¡å±•å¼€ç¬¦**
```javascript
Object.assign({}, state, {
    visibilityFilter: action.filter
  });
// ç­‰ä»·äº(å‡å¯è¿”å›ä¸€ä¸ªæ–°çš„å¯¹è±¡)
{ ...state, visibilityFilter: action.filter }
```

## è¸©è¿‡çš„å‘
* ä½¿ç”¨ `_.merge(object,[source])`_çš„æ—¶å€™ï¼Œä¼šè¿”å›mutableå¯¹è±¡(å¯¼è‡´ç»„ä»¶ä¸ä¼šé‡æ–°æ¸²æŸ“)ï¼Œæ‰€ä»¥å¯ä»¥æ¢ä¸ªæ–¹å¼ä½¿ç”¨ï¼Œå®ç°immutable: _<span style="color:#D03C3C;">_`_.merge({}, object, [source])`_</span>


```javascript
const characters = [ 'Obi-Wan', 'Vader' ]
const newCharacters = [ ...characters, 'Luke' ]
console.log(characters === newCharacters) // false
console.log(characters) // [ 'Obi-Wan', 'Vader' ]
console.log(newCharacters) // [ 'Obi-Wan', 'Vader', 'Luke' ]
// but
const object = [1];
const newObject = _.merge(object, [2]);
console.log(object === newObject); // true
console.log(newObject); // [1, 2]
```

