---
layout: post
title: \[è‰ç¨¿\]å¤åˆæ¨¡å¼
# category: è¯»ä¹¦ç¬”è®°/æ·±å…¥æµ…å‡ºè®¾è®¡æ¨¡å¼(Java)âœ¨âœ¨âœ¨âœ¨
---

> å…¶å®å°±æ˜¯é€šè¿‡ä¸€ä¸ªä¾‹å­ï¼Œäº†è§£å¸¸ç”¨çš„è®¾è®¡æ¨¡å¼çš„ç»„åˆä½¿ç”¨(å¤ªæ‡’äº†ï¼Œä¸å†™è¯´æ˜äº† ğŸ˜· )


ğŸ‘‰ [CodePen](https://codepen.io/kasmine/pen/ZXbQYw)

```javascript
// 1. create a Quackable interface
interface Quackable {
  quack(): void;
}

// 2. create some Duck to implement the Quackable interface
/**
 * @class MallarDuck
 * @desc standard MallarDuck - a kind of Duck
 */
class MallarDuck implements Quackable {
  quack() {
    console.log('Qauck');
  }
}
class RedheadDuck implements Quackable {
  quack() {
    console.log('Quack');
  }
}
/**
 * @class RubberDuck
 * @desc æ©¡çš®é¸­ - å«å£°ç‹¬ç‰¹
 */
class RubberDuck implements Quackable {
  quack() {
    console.log('Squeak');
  }
}

// 3. create a simulator, which can produce Duck and simulate quack
class DuckSimulator {
  constructor() {
    console.log('=== DuckSimulator Start ===');
    this.simulate();
    console.log('=== DuckSimulator End ===');    
  }

  simulate(): void {
    const redheadDuck = new RedheadDuck();
    const mallardDuck = new MallarDuck();
    const rubberDuck = new RubberDuck();

    this.simulateQuack(mallardDuck);
    this.simulateQuack(rubberDuck);
    this.simulateQuack(redheadDuck);
  }
  
  simulateQuack(duck: Quackable) {
    duck.quack();
  }
}

function demo1() {
  console.log('~~~~~ demo1 ~~~~~')  
  const simulator: DuckSimulator = new DuckSimulator();
}

demo1();

// 4. now, we create Goose
class Goose {
  constructor() {
  }
  hook(): void {
    console.log('hook');
  }
}
// 5. we want to use our Simulator to test Goose
// NOTE: **Adapter Pattern**
// we can use Adaptor to do this work
class GooseAdapter implements Quackable {

  private goose: Goose;
  constructor(goose: Goose) {
    this.goose = goose;
  }
  
  quack(): void {
    this.goose.hook();
  }

}

// 6. update our Simulator
// Let's try

class DuckSimulator_2 {
  constructor() {
    console.log('=== DuckSimulator Start ===');
    this.simulate();
    console.log('=== DuckSimulator End ===');    
  }

  simulate(): void {
    const redheadDuck = new RedheadDuck();
    const mallardDuck = new MallarDuck();
    const rubberDuck = new RubberDuck();

    const gooseDuck = new GooseAdapter(new Goose());
    this.simulateQuack(mallardDuck);
    this.simulateQuack(rubberDuck);
    this.simulateQuack(redheadDuck);
    this.simulateQuack(gooseDuck);
  }
  
  simulateQuack(duck: Quackable) {
    duck.quack();
  }
}


function demo2() {
  console.log('~~~~~ demo2 ~~~~~');  
  const simulator: DuckSimulator_2 = new DuckSimulator_2();
}

demo2();

/**
 * @desc 7. A new qustion: 
 *        - how can we calculate the num of quack without changing original Duck
 *       8. NOTE: **Decorator Pattern**
 *        - let's create a Decorator to do this
 */
class QuackCounter implements Quackable {

  private duck: Quackable;
  private static numberOfQuacks: number = 0;

  constructor(duck: Quackable) {
    this.duck = duck;
  }
  quack(): void {
    this.duck.quack();
    QuackCounter.numberOfQuacks++;
  }

  public static getQuacks() {
    // è·å–æ‰€æœ‰çš„é¸­å«å£°
    // NOTE: ä½¿ç”¨é™æ€æ–¹æ³•ï¼Œé™æ€å˜é‡ï¼Œæ‰€æœ‰è¯¥ç±»çš„å®ä¾‹å¯ä»¥å…±äº«
    return QuackCounter.numberOfQuacks;
  }
}

// 9. update our Simulator
class DuckSimulator_3 {
  constructor() {
    console.log('=== DuckSimulator Start ===');
    this.simulate();
    console.log('=== DuckSimulator End ===');    
  }

  simulate(): void {
    const redheadDuck = quackCounterDecorator(new RedheadDuck());
    const mallardDuck = quackCounterDecorator(new MallarDuck());
    const rubberDuck = quackCounterDecorator(new RubberDuck());

    const gooseDuck = new GooseAdapter(new Goose());
    this.simulateQuack(mallardDuck);
    this.simulateQuack(rubberDuck);
    this.simulateQuack(redheadDuck);
    this.simulateQuack(gooseDuck);

    console.log(`The duck quacked ${QuackCounter.getQuacks()} times`);
  }
  
  simulateQuack(duck: Quackable) {
    duck.quack();
  }
}

function quackCounterDecorator(duck: Quackable) {
  return new QuackCounter(duck);
}


function demo3() {
  console.log('~~~~~ demo3 ~~~~~');  
  const simulator: DuckSimulator_3 = new DuckSimulator_3();
}

demo3();

// 10. We should use Factory to produce Duck

// 11. **Abstract Factory Pattern**
abstract class AbstractDuckFactory {
   abstract createMallardDuck(): Quackable;
   abstract createRedHeadDuck(): Quackable;
   abstract createRubberDuck(): Quackable;
}
// DuckFactory without decrator
class DuckFactory extends AbstractDuckFactory {
  createMallardDuck(): Quackable {
    return new MallarDuck();
  }
  createRedHeadDuck(): Quackable {
    return new RedheadDuck();
  }
  createRubberDuck(): Quackable {
    return new RubberDuck();
  }
}
// DuckFactory with QuackCounter
class CountingDuckFactory extends AbstractDuckFactory {
  createMallardDuck(): Quackable {
    return quackCounterDecorator(new MallarDuck());
  }
  createRedHeadDuck(): Quackable {
    return quackCounterDecorator(new RedheadDuck());
  }
  createRubberDuck(): Quackable {
    return quackCounterDecorator(new RubberDuck());
  }
}

// 12. update Simulator, use DuckFactory to do the same thing as demo3
class DuckSimulator_4 {
  constructor() {
    console.log('=== DuckSimulator Start ===');
    const duckFacroty = new CountingDuckFactory();
    this.simulate(duckFacroty);
    console.log('=== DuckSimulator End ===');    
  }

  simulate(duckFactory: AbstractDuckFactory): void {
    // MODIFY here~
    const redheadDuck = duckFactory.createRedHeadDuck();
    const mallardDuck = duckFactory.createMallardDuck();
    const rubberDuck = duckFactory.createRubberDuck();

    const gooseDuck = new GooseAdapter(new Goose());
    this.simulateQuack(mallardDuck);
    this.simulateQuack(rubberDuck);
    this.simulateQuack(redheadDuck);
    this.simulateQuack(gooseDuck);

    console.log(`The duck quacked ${QuackCounter.getQuacks()} times`);
  }
  
  simulateQuack(duck: Quackable) {
    duck.quack();
  }
}

function demo4() {
  console.log('~~~~~ demo4 ~~~~~');  
  const simulator: DuckSimulator_4 = new DuckSimulator_4();
}
// NOTICE: 
// è¿™é‡Œå’Œdemo3 å…±ç”¨äº†åŒä¸€ä¸ªè£…é¥°å™¨ï¼Œæ‰€ä»¥ç»Ÿè®¡çš„ quackTimes is twice of the quackTimes in demo3
demo4();

// 13. ç‹¬ç«‹ä»»åŠ¡ ğŸ‘
// You are requested to write a AbstractGooseFactory, aiming to achieve a GooseDuck
abstract class AbstractGooseFactory {
  abstract createGoose(): Quackable;
}
class GooseDuckFactory extends AbstractGooseFactory {
  createGoose(): Quackable {
    return quackCounterDecorator(new GooseAdapter(new Goose()));
  }
}

class DuckSimulator_5 {
  constructor() {
    console.log('=== DuckSimulator Start ===');
    const duckFacroty = new CountingDuckFactory();
    this.simulate(duckFacroty);
    console.log('=== DuckSimulator End ===');    
  }

  simulate(duckFactory: AbstractDuckFactory): void {
    const redheadDuck = duckFactory.createRedHeadDuck();
    const mallardDuck = duckFactory.createMallardDuck();
    const rubberDuck = duckFactory.createRubberDuck();

    const gooseDuckFactory = new GooseDuckFactory();
    const gooseDuck = gooseDuckFactory.createGoose();
    this.simulateQuack(mallardDuck);
    this.simulateQuack(rubberDuck);
    this.simulateQuack(redheadDuck);
    this.simulateQuack(gooseDuck);

    console.log(`The duck quacked ${QuackCounter.getQuacks()} times`);
  }
  
  simulateQuack(duck: Quackable) {
    duck.quack();
  }
}

function demo5() {
  console.log('~~~~~ demo5 ~~~~~');  
  const simulator: DuckSimulator_5 = new DuckSimulator_5();
}
// NOTICE: 
// è¿™é‡Œå’Œdemo3 å…±ç”¨äº†åŒä¸€ä¸ªè£…é¥°å™¨ï¼Œæ‰€ä»¥ demo5 ç»Ÿè®¡çš„ quackTimes is 3 times of the quackTimes in demo3
demo5();

/**
 * @desc 14. A new Demand
 *         - How to manage these Duck more conveniently
 *         - Let's create a flock of duck(actually is Quackable)
 */
class Flock implements Quackable {

    private quackers: Set<Quackable> = new Set();
    add(duck: Quackable) {
      this.quackers.add(duck);
    }
    quack(): void {
      this.quackers.forEach(quacker => {
        quacker.quack();
      });
    }
}

class DuckSimulator_6 {
  constructor() {
    console.log('=== DuckSimulator Start ===');
    const duckFacroty = new CountingDuckFactory();
    this.simulate(duckFacroty);
    console.log('=== DuckSimulator End ===');    
  }

  simulate(duckFactory: AbstractDuckFactory): void {
    const gooseDuckFactory = new GooseDuckFactory();
    
    // ä¸»é¸­ç¾¤
    const flockOfDucks = new Flock();
    // ç»¿å¤´é¸­ç¾¤
    const flockOfMallarDuck = new Flock();

    const redheadDuck = duckFactory.createRedHeadDuck();
    const mallardDuck = duckFactory.createMallardDuck();
    const rubberDuck = duckFactory.createRubberDuck();
    const gooseDuck = gooseDuckFactory.createGoose();

    flockOfDucks.add(redheadDuck);
    flockOfDucks.add(mallardDuck);
    flockOfDucks.add(rubberDuck);
    flockOfDucks.add(gooseDuck);

    console.log('~~ To test FlockOfDucks ~~');
    flockOfDucks.quack();

    const mallardDuck01 = duckFactory.createMallardDuck();
    const mallardDuck02 = duckFactory.createMallardDuck();
    const mallardDuck03 = duckFactory.createMallardDuck();
    flockOfMallarDuck.add(mallardDuck01);
    flockOfMallarDuck.add(mallardDuck02);
    flockOfMallarDuck.add(mallardDuck03);

    console.log('~~ To test FlockOfMallarDuck ~~');
    flockOfMallarDuck.quack();
    
    console.log(`The duck quacked ${QuackCounter.getQuacks()} times`);
  }
  
  simulateQuack(duck: Quackable) {
    duck.quack();
  }
}
function demo6() {
  console.log('~~~~~ demo6 ~~~~~');  
  const simulator: DuckSimulator_6 = new DuckSimulator_6();
}
// NOTICE: 
// è¿™é‡Œå’Œdemo3 å…±ç”¨äº†åŒä¸€ä¸ªè£…é¥°å™¨ï¼Œæ‰€ä»¥ demo6 ç»Ÿè®¡çš„ quackTimes is 3 times of the quackTimes in demo3 + 7 = 16 times
demo6();

/**
 * @desc 15. Last Demand: Scholars want to be notified when ducks quack
 *        -  NOTE:
 *        - **Observer Pattern** 
 */
export abstract class AbstractObserver {
  abstract update(observable: AbstractObservable);
}

export abstract class AbstractObservable {
  abstract register(observer: AbstractObserver);
  abstract remove(observer: AbstractObserver);
  abstract removeAll();
  abstract notify(observer: AbstractObserver);
  abstract notifyAll();
}

/**
 * @class QuackObserver
 * @extends AbstractObserver
 * @desc é¸­å« - è§‚å¯Ÿè€…
 */
class QuackObserver extends AbstractObserver {
  constructor(duck: Quackable) {
    super();
  }
  update(duck: QuackObservable) {
  }
}

/**
 * @class QuackObservable
 * @extends AbstractObservable
 * @desc è¢«è§‚å¯Ÿè€… - å„ç§ç§ç±»çš„é¸­å­
 */
class QuackObservable extends AbstractObservable {

  private observers: Set<QuackObserver> = new Set();
  private duck: QuackObservable;
  constructor(duck: QuackObservable) {
    super();
    this.duck = duck;
  }
  register(observer: QuackObserver) {
    this.observers.add(observer);
  }
  
  remove(observer: QuackObserver) {
    this.observers.delete(observer);
  }
  
  removeAll() {
    this.observers.clear();
  }

  notify (observer: QuackObserver) {

  }
  
  notifyAll() {
    this.observers.forEach(observer => {
      observer.update(this.duck);
    });
  }
}

/**
 * @interface Quackable
 * @extends QuackObservable
 * @desc é‡æ–°æ‰©å±• Quackableç±»ï¼Œå®ç°è¢«è§‚å¯Ÿè€…çš„æ¥å£
 */

// interface Quackable extends QuackObservable {
//   quack(): void;
// }

/**
 * TODO: æœªå®Œï½ï½
 */

// class MallardDuck implements Quackable {
  
//   observer: QuackObserver;
//   constructor() {
//     this.observer = new QuackObserver(this);
//   }
//   quack() {
//     console.log('MallardDuck quack');
//     // this.no
//   }
// }
```

